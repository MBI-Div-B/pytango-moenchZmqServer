{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MOENCH ZMQ TangoDS documentation!","text":""},{"location":"#commands","title":"Commands","text":"graph TD A[Client] --&gt; B[Load Balancer] B --&gt; C[Server01] B --&gt; D[Server02]  <pre><code>def function(self, a : str):\n    print(self.test(a))\n</code></pre>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"detector/","title":"Detector reference","text":""},{"location":"detector/#json-headers","title":"JSON headers","text":"<p>This is the format for 6.1.2 (example with Moench): <pre><code>{\n\"jsonversion\": 4,\n\"bitmode\": 16,\n\"fileIndex\": 0,\n\"detshape\": [\n1,\n1\n],\n\"shape\": [\n400,\n400\n],\n\"size\": 320000,\n\"acqIndex\": 4,\n\"frameIndex\": 0,\n\"progress\": 100.0,\n\"fname\": \"//run\",\n\"data\": 1,\n\"completeImage\": 1,\n\"frameNumber\": 4,\n\"expLength\": 0,\n\"packetNumber\": 239,\n\"bunchId\": 0,\n\"timestamp\": 0,\n\"modId\": 0,\n\"row\": 0,\n\"column\": 0,\n\"reserved\": 0,\n\"debug\": 0,\n\"roundRNumber\": 0,\n\"detType\": 5,\n\"version\": 1,\n\"flipRows\": 0,\n\"quad\": 0,\n\"addJsonHeader\": {\n\"emin\": \"500\"\n}\n}\n</code></pre></p> <p>Changes from  6.x.x to 7.0.0: 4 field names have changed from 6.x.x to 7.x.x because they have also been changed in the detector udp header.  Since the meaning has not changed, the udp header version stays the same as well as the  zmq header version. detSpec1 &lt;- bunchId detSpec2 &lt;- reserved detSpec3 &lt;- debug detSpec4 &lt;- roundRNumber</p> <p>In case, you were wondering about the type: <pre><code>{\n\"jsonversion\": unsigned int,\n\"bitmode\": unsigned int,\n\"fileIndex\": unsigned long int,\n\"detshape\": [\nunsigned int,\nunsigned int\n],\n\"shape\": [\nunsigned int,\nunsigned int\n],\n\"size\": unsigned int,\n\"acqIndex\": unsigned long int,\n\"frameIndex\": unsigned long int,\n\"progress\": double,\n\"fname\": string,\n\"data\": unsigned int,\n\"completeImage\": unsigned int,\n\n\"frameNumber\": unsigned long long int,\n\"expLength\": unsigned int,\n\"packetNumber\": unsigned int,\n\"detSpec1\": unsigned long int,\n\"timestamp\": unsigned long int,\n\"modId\": unsigned int,\n\"row\": unsigned int,\n\"column\": unsigned int,\n\"detSpec2\": unsigned int,\n\"detSpec3\": unsigned int,\n\"detSpec4\": unsigned int,\n\"detType\": unsigned int,\n\"version\": unsigned int,\n\n\"flipRows\": unsigned int,\n\"quad\": unsigned int,\n\"addJsonHeader\": {\nstring : string\n}\n}\n</code></pre></p> Field Description jsonversion Version of the json header. Value at 4 for v6.x.x   and v7.x.x bitmode Bits per pixel [4|8|16|32] fileIndex Current file acquisition index detshape Geometry of the entire detector shape Geometry of the current port streamed out size Size of image of current port in bytesout acqIndex Frame number from the detector (redundant) frameIndex Frame number of current acquisition (Starting at 0) progress Progress of current acquisition in % fname Current file name data 1 if there is data following 0 if dummy header completeImage 1 if no missing packets for this frame in this port,   else 0 frameNumber Frame number [From detector udp header] expLength subframe number (32 bit eiger) or real time exposure   time in 100ns (others) [From detector udp header] packetNumber Number of packets caught for that frame detSpec1 See here [From detector udp header] timestamp Timestamp with 10 MHz clock [From detector udp   header] modId Module Id [From detector udp header] row Row number in detector [From detector udp header] column Column number in detector [From detector udp header] detSpec2 See here [From detector udp header] detSpec3 See here [From detector udp header] detSpec4 See here [From detector udp header] detType detSpec3 Detector type enum See Detector enum [From   detector udp header] version Detector header version. At 2 [From detector udp   header] flipRows 1 if rows should be flipped. Usually for Eiger bottom. quad 1 if its an Eiger quad. addJsonHeader Optional custom parameters that is required for   processing code."},{"location":"guideline/","title":"Coding guideline","text":""},{"location":"guideline/#asynchronous-io","title":"Asynchronous IO","text":"<p>smart way to handle zmq requests</p>"},{"location":"guideline/#multiprocessing","title":"Multiprocessing","text":"<p>ProcessPoolExecutor, memory manager and locks (mutex)</p>"},{"location":"guideline/#shared-memory","title":"Shared memory","text":"<p>Here is a small explanation why the threshold is handled in other way as images buffers: Despite the fact there is a thread safe \"multiprocessing.Value\" class for scalars (see above), there is no class for 2D array. Yes, there are 1D arrays available (see \"multiprocessing.Array\"), but they need to be handled as python arrays and not as numpy arrays. Continuos rearrangement of them into numpy arrays and vise versa considered as bad. In python 3.8 shared memory feature was introduced which allows to work directly with memory and use a numpy array as proxy to it. Documentation: https://docs.python.org/3.8/library/multiprocessing.shared_memory.html A good example: https://luis-sena.medium.com/sharing-big-numpy-arrays-across-python-processes-abf0dc2a0ab2</p> <p>tl;dr: we are able to share any numpy array between processes but in little other way</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#dependencies","title":"Dependencies","text":"<ul> <li>python 3.10</li> <li>pyzmq</li> <li>pytango</li> <li>Pillow</li> <li>scipy</li> <li>skicit-image</li> </ul> <p>Warning</p> <p>python3.8 is broken</p> <p>Note</p> <p>python3.10 works though</p>"},{"location":"installation/#inital-setup","title":"Inital setup","text":"<p>tango ds properties table:</p> <pre><code>ZMQ_RX_IP = device_property(\n    dtype=str,\n    doc=\"port of the slsReceiver instance, must match the config\",\n    default_value=\"192.168.2.200\",\n)\n\nZMQ_RX_PORT = device_property(\n    dtype=str,\n    doc=\"ip of slsReceiver instance, must match the config\",\n    default_value=\"50003\",\n)\n\nPROCESSING_CORES = device_property(\n    dtype=int,\n    doc=\"cores amount to process, up to 72 on MOENCH workstation\",\n    default_value=20,\n)\nFLIP_IMAGE = device_property(\n    dtype=bool,\n    doc=\"should the final image be flipped/inverted along y-axis\",\n    default_value=True,\n)\n</code></pre>"},{"location":"reference/","title":"Code reference","text":""},{"location":"reference/#MoenchZmqServer.MoenchZmqServer","title":"<code>MoenchZmqServer</code>","text":"<p>         Bases: <code>Device</code></p> <p>Custom implementation of zmq processing server for X-ray detector MOENCH made in PSI which is integrated with a Tango device server.</p> Source code in <code>pytango-moenchZmqServer\\MoenchZmqServer.py</code> <pre><code>class MoenchZmqServer(Device):\n\"\"\"Custom implementation of zmq processing server for X-ray detector MOENCH made in PSI which is integrated with a Tango device server.\"\"\"\n\n    processing_function = None\n    processing_function_enum = ProcessingMode(0)\n\n    _manager = None\n    _context = None\n    _socket = None\n    _process_pool = None\n    green_mode = GreenMode.Asyncio\n\n    # probably should be rearranged in array, because there will pumped and unpumped images, for each type of processing\n    # and further loaded with dynamic attributes\n    shared_memory_pedestal = None\n    shared_memory_analog_img = None\n    shared_memory_threshold_img = None\n    shared_memory_counting_img = None\n\n    shared_threshold = None\n    shared_counting_threshold = None\n    shared_processed_frames = None\n    shared_amount_frames = None\n    shared_server_running = False\n\n    _save_analog_img = True\n    _save_threshold_img = True\n    _save_counting_img = True\n\n    ZMQ_RX_IP = device_property(\n        dtype=str,\n        doc=\"port of the slsReceiver instance, must match the config\",\n        default_value=\"192.168.2.200\",\n    )\n    ZMQ_RX_PORT = device_property(\n        dtype=str,\n        doc=\"ip of slsReceiver instance, must match the config\",\n        default_value=\"50003\",\n    )\n    PROCESSING_CORES = device_property(\n        dtype=int,\n        doc=\"cores amount to process, up to 72 on MOENCH workstation\",\n        default_value=20,\n    )\n    FLIP_IMAGE = device_property(\n        dtype=bool,\n        doc=\"should the final image be flipped/inverted along y-axis\",\n        default_value=True,\n    )\n\n    pedestal = attribute(\n        display_level=DispLevel.EXPERT,\n        label=\"pedestal\",\n        dtype=float,\n        dformat=AttrDataFormat.IMAGE,\n        max_dim_x=400,\n        max_dim_y=400,\n        access=AttrWriteType.READ_WRITE,\n        doc=\"pedestal (averaged dark images), i.e. offset which will be subtracted from each acquired picture\",\n    )\n    analog_img = attribute(\n        display_level=DispLevel.EXPERT,\n        label=\"analog img\",\n        dtype=float,\n        dformat=AttrDataFormat.IMAGE,\n        max_dim_x=400,\n        max_dim_y=400,\n        access=AttrWriteType.READ,\n        doc=\"sum of images processed with subtracted pedestals\",\n    )\n    threshold_img = attribute(\n        display_level=DispLevel.EXPERT,\n        label=\"threshold img\",\n        dtype=float,\n        dformat=AttrDataFormat.IMAGE,\n        max_dim_x=400,\n        max_dim_y=400,\n        access=AttrWriteType.READ,\n        doc='sum of \"analog images\" (with subtracted pedestal) processed with thresholding algorithm',\n    )\n    counting_img = attribute(\n        display_level=DispLevel.EXPERT,\n        label=\"counting img\",\n        dtype=float,\n        dformat=AttrDataFormat.IMAGE,\n        max_dim_x=400,\n        max_dim_y=400,\n        access=AttrWriteType.READ,\n        doc='sum of \"analog images\" (with subtracted pedestal) processed with counting algorithm',\n    )\n\n    threshold = attribute(\n        label=\"th\",\n        unit=\"ADU\",\n        dtype=float,\n        min_value=0.0,\n        access=AttrWriteType.READ_WRITE,\n        memorized=True,\n        hw_memorized=True,\n        doc=\"cut-off value for thresholding\",\n    )\n    counting_threshold = attribute(\n        label=\"counting th\",\n        unit=\"ADU\",\n        dtype=float,\n        min_value=0.0,\n        access=AttrWriteType.READ_WRITE,\n        memorized=True,\n        hw_memorized=True,\n        doc=\"cut-off value for counting\",\n    )\n    processing_mode = attribute(\n        label=\"mode\",\n        dtype=ProcessingMode,\n        access=AttrWriteType.READ_WRITE,\n        memorized=True,\n        hw_memorized=True,\n        fisallowed=\"isWriteAvailable\",\n        doc=\"mode of frames processing [ANALOG = 0, THRESHOLD = 1, COUNTING = 2]\",\n    )\n\n    processed_frames = attribute(\n        label=\"proc frames\",\n        dtype=int,\n        access=AttrWriteType.READ,\n        doc=\"amount of already processed frames\",\n    )\n    amount_frames = attribute(\n        label=\"amount frames\",\n        dtype=int,\n        access=AttrWriteType.READ,\n        doc=\"expected frames to receive from detector\",\n    )\n\n    server_running = attribute(\n        display_level=DispLevel.EXPERT,\n        label=\"is server running?\",\n        dtype=bool,\n        access=AttrWriteType.READ,\n        doc=\"if true - server is running, otherwise - not\",\n    )\n\n    save_analog_img = attribute(\n        label=\"save analog\",\n        dtype=bool,\n        access=AttrWriteType.READ_WRITE,\n        memorized=True,\n        hw_memorized=True,\n        doc=\"save analog .tiff file after acquisition\",\n    )\n\n    save_threshold_img = attribute(\n        label=\"save threshold\",\n        dtype=bool,\n        access=AttrWriteType.READ_WRITE,\n        memorized=True,\n        hw_memorized=True,\n        doc=\"save threshold .tiff file after acquisition\",\n    )\n\n    save_counting_img = attribute(\n        label=\"save counting\",\n        dtype=bool,\n        access=AttrWriteType.READ_WRITE,\n        memorized=True,\n        hw_memorized=True,\n        doc=\"save counting .tiff file after acquisition\",\n    )\n\n    def write_pedestal(self, value):\n        self.shared_pedestal.value = value\n\n    def read_pedestal(self):\n        return self._read_shared_array(\n            shared_memory=self.shared_memory_pedestal, flip=self.FLIP_IMAGE\n        )\n\n    def write_analog_img(self, value):\n        self.shared_analog_img.value = value\n\n    def read_analog_img(self):\n        return self._read_shared_array(\n            shared_memory=self.shared_memory_analog_img, flip=self.FLIP_IMAGE\n        )\n\n    def write_threshold_img(self, value):\n        self.shared_threshold_img.value = value\n\n    def read_threshold_img(self):\n        return self._read_shared_array(\n            shared_memory=self.shared_memory_threshold_img, flip=self.FLIP_IMAGE\n        )\n\n    def write_counting_img(self, value):\n        self.shared_counting_img.value = value\n\n    def read_counting_img(self):\n        return self._read_shared_array(\n            shared_memory=self.shared_memory_counting_img, flip=self.FLIP_IMAGE\n        )\n\n    def write_threshold(self, value):\n        self.shared_threshold.value = value\n\n    def read_threshold(self):\n        return self.shared_threshold.value\n\n    def write_counting_threshold(self, value):\n        self.shared_counting_threshold.value = value\n\n    def read_counting_threshold(self):\n        return self.shared_counting_threshold.value\n\n    def write_processing_mode(self, value):\n        # matching values and functions [ANALOG = 0, THRESHOLD = 1, COUNTING = 2]\n        self.processing_function_enum = ProcessingMode(value)\n        match self.processing_function_enum:\n            case ProcessingMode.ANALOG:\n                self.processing_function =  processing_functions.analog\n            case ProcessingMode.THRESHOLD:\n                self.processing_function = processing_functions.thresholding\n            case ProcessingMode.COUNTING:\n                self.processing_function = processing_functions.counting\n\n    def read_processing_mode(self):\n        return self.processing_function_enum\n\n    def write_processed_frames(self, value):\n        self.shared_processed_frames.value = value\n\n    def read_processed_frames(self):\n        return self.shared_processed_frames.value\n\n    def write_amount_frames(self, value):\n        self.shared_amount_frames.value = value\n\n    def read_amount_frames(self):\n        return self.shared_amount_frames.value\n\n    def write_server_running(self, value):\n        self.shared_server_running.value = int(value)\n\n    def read_server_running(self):\n        return bool(self.shared_server_running.value)\n\n    def write_save_analog_img(self, value):\n        self._save_analog_img = value\n\n    def read_save_analog_img(self):\n        return self._save_analog_img\n\n    def write_save_threshold_img(self, value):\n        self._save_threshold_img = value\n\n    def read_save_threshold_img(self):\n        return self._save_threshold_img\n\n    def write_save_counting_img(self, value):\n        self._save_counting_img = value\n\n    def read_save_counting_img(self):\n        return self._save_counting_img\n\n    # when processing is ready -&gt; self.push_change_event(self, \"analog_img\"/\"counting_img\"/\"threshold_img\")\n\n    async def main(self):\n        while True:\n            header, payload = await self.get_msg_pair()\n            if payload is not None:\n                # wrap_function(header, payload, lock, shared_memory, processed_frames, frame_func, *args, **kwargs):\n                future = self._process_pool.submit(\n                    wrap_function,\n                    header,\n                    payload,\n                    self._lock,\n                    self.shared_memory_analog_img, # need to changed corresponding to the frame_func\n                    self.shared_processed_frames,\n                    self.processing_function\n                )\n                future = asyncio.wrap_future(future)\n\n    async def get_msg_pair(self):\n        isNextPacketData = True\n        header = None\n        payload = None\n        packet1 = await self._socket.recv()\n        try:\n            print(\"parsing header...\")\n            header = json.loads(packet1)\n            print(header)\n            isNextPacketData = header.get(\"data\") == 1\n            print(f\"isNextPacketdata {isNextPacketData}\")\n        except:\n            print(\"is not header\")\n            isNextPacketData = False\n        if isNextPacketData:\n            print(\"parsing data...\")\n            packet2 = await self._socket.recv()\n            payload = np.frombuffer(packet2, dtype=np.uint16).reshape((400, 400))\n        return header, payload\n\n    def _read_shared_array(self, shared_memory, flip: bool):\n        array = np.ndarray((400, 400), dtype=float, buffer=shared_memory.buf)\n        if flip:\n            return np.flipud(array)\n        else:\n            return array\n\n    @command\n    def start_receiver(self):\n        self.write_server_running(True)\n        pass\n\n    @command\n    def stop_receiver(self):\n        self.write_server_running(False)\n        # self.save_files()\n\n    @command\n    def acquire_pedestals(self):\n        pass\n\n    def init_device(self):\n\"\"\"Initial tangoDS setup\"\"\"\n        Device.init_device(self)\n        self.set_state(DevState.INIT)\n        self.get_device_properties(self.get_device_class())\n        # sync manager for synchronization between threads\n        self._manager = mp.Manager()\n        # using simple mutex (lock) to synchronize\n        self._lock = self._manager.Lock()\n\n        # manager for allocation of shared memory between threads\n        self._shared_memory_manager = SharedMemoryManager()\n        # starting the shared memory manager\n        self._shared_memory_manager.start()\n        # default values of properties do not work without database though \u00af\\_(\u30c4)_/\u00af\n        processing_cores_amount = 16  # self.PROCESSING_CORES\n        zmq_ip = self.ZMQ_RX_IP\n        zmq_port = self.ZMQ_RX_PORT\n\n        # using shared threadsafe Value instance from multiprocessing\n        self.shared_threshold = self._manager.Value(\"f\", 0)\n        self.shared_counting_threshold = self._manager.Value(\"f\", 0)\n        self.shared_server_running = self._manager.Value(\"b\", 0)\n        self.shared_processed_frames = self._manager.Value(\"I\", 0)\n        self.shared_amount_frames = self._manager.Value(\"I\", 0)\n        # calculating how many bytes need to be allocated and shared for a 400x400 float numpy array\n        img_bytes = np.zeros([400, 400], dtype=float).nbytes\n        # allocating 4 arrays of this type\n        self.shared_memory_pedestal = self._shared_memory_manager.SharedMemory(\n            size=img_bytes\n        )\n        self.shared_memory_analog_img = self._shared_memory_manager.SharedMemory(\n            size=img_bytes\n        )\n        self.shared_memory_threshold_img = self._shared_memory_manager.SharedMemory(\n            size=img_bytes\n        )\n        self.shared_memory_counting_img = self._shared_memory_manager.SharedMemory(\n            size=img_bytes\n        )\n        # creating thread pool executor to which the frame processing will be assigned\n        self._process_pool = ProcessPoolExecutor(processing_cores_amount)\n\n        # creating and initialing socket to read from\n        self._init_zmq_socket(zmq_ip, zmq_port)\n        loop = asyncio.get_event_loop()\n        loop.create_task(self.main())\n\n        # initialization of tango events for pictures buffers\n        self.set_change_event(\"analog_img\", True, False)\n        self.set_change_event(\"threshold_img\", True, False)\n        self.set_change_event(\"counting_img\", True, False)\n        self.set_state(DevState.ON)\n\n    # updating of tango events for pictures buffers\n    @command\n    def update_images_events(self):\n        self.push_change_event(\"analog_img\", self.read_analog_img(), 400, 400),\n        self.push_change_event(\"threshold_img\", self.read_threshold_img(), 400, 400)\n        self.push_change_event(\"counting_img\", self.read_counting_img(), 400, 400)\n\n    # save files on disk for pictures buffers\n    def save_files(self, path, filename, index):\n\"\"\"Function for saving the buffered images in .tiff format.\n        The files will have different postfixes depending on processing mode.\n\n        Args:\n            path (str): folder to save\n            filename (str): name to save\n            index (str): capture index\n        \"\"\"\n        savepath = os.path.join(path, filename)\n        if self.read_save_analog_img():\n            im = Image.fromarray(self.read_analog_img())\n            im.save(f\"{savepath}_{index}_analog.tiff\")\n\n        if self.read_save_threshold_img():\n            im = Image.fromarray(self.read_threshold_img())\n            im.save(f\"{savepath}_{index}_threshold_{self.read_threshold()}.tiff\")\n\n        if self.read_save_counting_img():\n            im = Image.fromarray(self.read_analog_img())\n            im.save(\n                f\"{savepath}_{index}_counting_{self.read_counting_threshold()}.tiff\"\n            )\n\n    def _init_zmq_socket(self, zmq_ip: str, zmq_port: str):\n        endpoint = f\"tcp://{zmq_ip}:{zmq_port}\"\n        self._context = zmq.asyncio.Context()\n        self._socket = self._context.socket(zmq.SUB)\n        print(f\"Connecting to: {endpoint}\")\n        self._socket.connect(endpoint)\n        self._socket.setsockopt(zmq.SUBSCRIBE, b\"\")\n\n    def delete_device(self):\n        self._process_pool.shutdown()\n        self._manager.shutdown()\n        self._shared_memory_manager.shutdown()\n</code></pre>"},{"location":"reference/#MoenchZmqServer.MoenchZmqServer.init_device","title":"<code>init_device()</code>","text":"<p>Initial tangoDS setup</p> Source code in <code>pytango-moenchZmqServer\\MoenchZmqServer.py</code> <pre><code>def init_device(self):\n\"\"\"Initial tangoDS setup\"\"\"\n    Device.init_device(self)\n    self.set_state(DevState.INIT)\n    self.get_device_properties(self.get_device_class())\n    # sync manager for synchronization between threads\n    self._manager = mp.Manager()\n    # using simple mutex (lock) to synchronize\n    self._lock = self._manager.Lock()\n\n    # manager for allocation of shared memory between threads\n    self._shared_memory_manager = SharedMemoryManager()\n    # starting the shared memory manager\n    self._shared_memory_manager.start()\n    # default values of properties do not work without database though \u00af\\_(\u30c4)_/\u00af\n    processing_cores_amount = 16  # self.PROCESSING_CORES\n    zmq_ip = self.ZMQ_RX_IP\n    zmq_port = self.ZMQ_RX_PORT\n\n    # using shared threadsafe Value instance from multiprocessing\n    self.shared_threshold = self._manager.Value(\"f\", 0)\n    self.shared_counting_threshold = self._manager.Value(\"f\", 0)\n    self.shared_server_running = self._manager.Value(\"b\", 0)\n    self.shared_processed_frames = self._manager.Value(\"I\", 0)\n    self.shared_amount_frames = self._manager.Value(\"I\", 0)\n    # calculating how many bytes need to be allocated and shared for a 400x400 float numpy array\n    img_bytes = np.zeros([400, 400], dtype=float).nbytes\n    # allocating 4 arrays of this type\n    self.shared_memory_pedestal = self._shared_memory_manager.SharedMemory(\n        size=img_bytes\n    )\n    self.shared_memory_analog_img = self._shared_memory_manager.SharedMemory(\n        size=img_bytes\n    )\n    self.shared_memory_threshold_img = self._shared_memory_manager.SharedMemory(\n        size=img_bytes\n    )\n    self.shared_memory_counting_img = self._shared_memory_manager.SharedMemory(\n        size=img_bytes\n    )\n    # creating thread pool executor to which the frame processing will be assigned\n    self._process_pool = ProcessPoolExecutor(processing_cores_amount)\n\n    # creating and initialing socket to read from\n    self._init_zmq_socket(zmq_ip, zmq_port)\n    loop = asyncio.get_event_loop()\n    loop.create_task(self.main())\n\n    # initialization of tango events for pictures buffers\n    self.set_change_event(\"analog_img\", True, False)\n    self.set_change_event(\"threshold_img\", True, False)\n    self.set_change_event(\"counting_img\", True, False)\n    self.set_state(DevState.ON)\n</code></pre>"},{"location":"reference/#MoenchZmqServer.MoenchZmqServer.save_files","title":"<code>save_files(path, filename, index)</code>","text":"<p>Function for saving the buffered images in .tiff format. The files will have different postfixes depending on processing mode.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>folder to save</p> required <code>filename</code> <code>str</code> <p>name to save</p> required <code>index</code> <code>str</code> <p>capture index</p> required Source code in <code>pytango-moenchZmqServer\\MoenchZmqServer.py</code> <pre><code>def save_files(self, path, filename, index):\n\"\"\"Function for saving the buffered images in .tiff format.\n    The files will have different postfixes depending on processing mode.\n\n    Args:\n        path (str): folder to save\n        filename (str): name to save\n        index (str): capture index\n    \"\"\"\n    savepath = os.path.join(path, filename)\n    if self.read_save_analog_img():\n        im = Image.fromarray(self.read_analog_img())\n        im.save(f\"{savepath}_{index}_analog.tiff\")\n\n    if self.read_save_threshold_img():\n        im = Image.fromarray(self.read_threshold_img())\n        im.save(f\"{savepath}_{index}_threshold_{self.read_threshold()}.tiff\")\n\n    if self.read_save_counting_img():\n        im = Image.fromarray(self.read_analog_img())\n        im.save(\n            f\"{savepath}_{index}_counting_{self.read_counting_threshold()}.tiff\"\n        )\n</code></pre>"},{"location":"reference/#MoenchZmqServer.wrap_function","title":"<code>wrap_function(header, payload, lock, shared_memory, processed_frames, amount_frames, frame_func, *args, **kwargs)</code>","text":"<p>Decorator to wrap any processing function applied for a single frame </p> <p>Parameters:</p> Name Type Description Default <code>header</code> <code>dict</code> <p>JSON formatted header from the detector </p> required <code>payload</code> <code>np.array</code> <p>np.array formatted single frame from the detector </p> required <code>lock</code> <code>multiprocessing.Lock</code> <p>lock (mutex) to provide synchronization for shared memory write</p> required <code>shared_memory</code> <code>shared_memory.SharedMemory</code> <p>shared memory instance for image buffer</p> required <code>processed_frames</code> <code>multiprocessing.Value</code> <p>shared value instance to increment to track how many frames were processed</p> required <code>amount_frames</code> <code>multiprocessing.Value</code> <p>shared value instance with amount of frames to expect</p> required <code>frame_func</code> <code>function</code> <p>any function with following signature: function(frame : np.array, dark : np.array, args, *kwargs) -&gt; result : np.array\"</p> required Source code in <code>pytango-moenchZmqServer\\MoenchZmqServer.py</code> <pre><code>def wrap_function(header, payload, lock, shared_memory, processed_frames, amount_frames, frame_func, *args, **kwargs):\n\"\"\"Decorator to wrap any processing function applied for a single frame \n\n    Args:\n        header (dict): JSON formatted header from the detector \n        payload (np.array): np.array formatted single frame from the detector \n        lock (multiprocessing.Lock): lock (mutex) to provide synchronization for shared memory write\n        shared_memory (shared_memory.SharedMemory): shared memory instance for image buffer\n        processed_frames (multiprocessing.Value): shared value instance to increment to track how many frames were processed\n        amount_frames (multiprocessing.Value): shared value instance with amount of frames to expect\n        frame_func (function): any function with following signature: function(frame : np.array, dark : np.array, *args, **kwargs) -&gt; result : np.array\"\n    \"\"\"\n    frame_index = header.get(\"frameIndex\")\n    frame_processed = frame_func(payload)\n    lock.acquire()\n    print(f\"Enter processing frame {frame_index}\")\n    img_buffer = np.ndarray((400, 400), dtype=float, buffer=shared_memory.buf)\n    img_buffer += frame_processed\n    processed_frames.value += 1\n    print(f\"Processed frames {processed_frames.value}/{amount_frames.value}\")\n    if processed_frames.value == amount_frames.value:\n        print(\"All frames processed =&gt; call \\\"stop receiver procedure\\\"\")\n    print(f\"Left processing frame {frame_index}\")\n    lock.release()\n</code></pre>"}]}