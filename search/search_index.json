{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Home"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"detector/","text":"Detector reference","title":"Detector reference"},{"location":"detector/#detector-reference","text":"","title":"Detector reference"},{"location":"installation/","text":"Installation","title":"Installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"reference/","text":"Reference MoenchZmqServer Bases: Device Custom implementation of zmq processing server for X-ray detector M\u00d6NCH made in PSI which is integrated with a Tango device server. Source code in pytango-moenchZmqServer\\MoenchZmqServer.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 class MoenchZmqServer ( Device ): \"\"\"Custom implementation of zmq processing server for X-ray detector M\u00d6NCH made in PSI which is integrated with a Tango device server.\"\"\" _manager = None _context = None _socket = None _process_pool = None green_mode = GreenMode . Asyncio # probably should be rearranged in array, because there will pumped and unpumped images, for each type of processing # and further loaded with dynamic attributes shared_memory_pedestal = None shared_memory_analog_img = None shared_memory_threshold_img = None shared_memory_counting_img = None shared_threshold = None shared_counting_threshold = None shared_processed_frames = None shared_amount_frames = None shared_server_running = False _save_analog_img = True _save_threshold_img = True _save_counting_img = True ZMQ_RX_IP = device_property ( dtype = str , doc = \"port of the slsReceiver instance, must match the config\" , default_value = \"192.168.2.200\" , ) ZMQ_RX_PORT = device_property ( dtype = str , doc = \"ip of slsReceiver instance, must match the config\" , default_value = \"50003\" , ) PROCESSING_CORES = device_property ( dtype = int , doc = \"cores amount to process, up to 72 on MOENCH workstation\" , default_value = 20 , ) FLIP_IMAGE = device_property ( dtype = bool , doc = \"should the final image be flipped/inverted along y-axis\" , default_value = True , ) pedestal = attribute ( display_level = DispLevel . EXPERT , label = \"pedestal\" , dtype = float , dformat = AttrDataFormat . IMAGE , max_dim_x = 400 , max_dim_y = 400 , access = AttrWriteType . READ_WRITE , doc = \"pedestal (averaged dark images), i.e. offset which will be subtracted from each acquired picture\" , ) analog_img = attribute ( display_level = DispLevel . EXPERT , label = \"analog img\" , dtype = float , dformat = AttrDataFormat . IMAGE , max_dim_x = 400 , max_dim_y = 400 , access = AttrWriteType . READ , doc = \"sum of images processed with subtracted pedestals\" , ) threshold_img = attribute ( display_level = DispLevel . EXPERT , label = \"threshold img\" , dtype = float , dformat = AttrDataFormat . IMAGE , max_dim_x = 400 , max_dim_y = 400 , access = AttrWriteType . READ , doc = 'sum of \"analog images\" (with subtracted pedestal) processed with thresholding algorithm' , ) counting_img = attribute ( display_level = DispLevel . EXPERT , label = \"counting img\" , dtype = float , dformat = AttrDataFormat . IMAGE , max_dim_x = 400 , max_dim_y = 400 , access = AttrWriteType . READ , doc = 'sum of \"analog images\" (with subtracted pedestal) processed with counting algorithm' , ) threshold = attribute ( label = \"th\" , unit = \"ADU\" , dtype = float , access = AttrWriteType . READ_WRITE , hw_memorized = True , doc = \"cut-off value for thresholding\" , ) counting_threshold = attribute ( label = \"counting th\" , unit = \"ADU\" , dtype = float , access = AttrWriteType . READ_WRITE , hw_memorized = True , doc = \"cut-off value for counting\" , ) processed_frames = attribute ( label = \"proc frames\" , dtype = int , access = AttrWriteType . READ_WRITE , doc = \"amount of already processed frames\" , ) amount_frames = attribute ( label = \"amount frames\" , dtype = int , access = AttrWriteType . READ_WRITE , doc = \"expected frames to receive from detector\" , ) server_running = attribute ( display_level = DispLevel . EXPERT , label = \"is server running?\" , dtype = bool , access = AttrWriteType . READ_WRITE , doc = \"if true - server is running, otherwise - not\" , ) save_analog_img = attribute ( label = \"save analog\" , dtype = bool , access = AttrWriteType . READ_WRITE , memorized = True , hw_memorized = True , doc = \"save analog .tiff file after acquisition\" , ) save_threshold_img = attribute ( label = \"save threshold\" , dtype = bool , access = AttrWriteType . READ_WRITE , memorized = True , hw_memorized = True , doc = \"save threshold .tiff file after acquisition\" , ) save_counting_img = attribute ( label = \"save counting\" , dtype = bool , access = AttrWriteType . READ_WRITE , memorized = True , hw_memorized = True , doc = \"save counting .tiff file after acquisition\" , ) def write_pedestal ( self , value ): self . shared_pedestal . value = value def read_pedestal ( self ): return self . _read_shared_array ( shared_memory = self . shared_memory_pedestal , flip = self . FLIP_IMAGE ) def write_analog_img ( self , value ): self . shared_analog_img . value = value def read_analog_img ( self ): return self . _read_shared_array ( shared_memory = self . shared_memory_analog_img , flip = self . FLIP_IMAGE ) def write_threshold_img ( self , value ): self . shared_threshold_img . value = value def read_threshold_img ( self ): return self . _read_shared_array ( shared_memory = self . shared_memory_threshold_img , flip = self . FLIP_IMAGE ) def write_counting_img ( self , value ): self . shared_counting_img . value = value def read_counting_img ( self ): return self . _read_shared_array ( shared_memory = self . shared_memory_counting_img , flip = self . FLIP_IMAGE ) def write_threshold ( self , value ): self . shared_threshold . value = value def read_threshold ( self ): return self . shared_threshold . value def write_counting_threshold ( self , value ): self . shared_counting_threshold . value = value def read_counting_threshold ( self ): return self . shared_counting_threshold . value def write_processed_frames ( self , value ): self . shared_processed_frames . value = value def read_processed_frames ( self ): return self . shared_processed_frames . value def write_amount_frames ( self , value ): self . shared_amount_frames . value = value def read_amount_frames ( self ): return self . shared_amount_frames . value def write_server_running ( self , value ): self . shared_server_running . value = int ( value ) def read_server_running ( self ): return bool ( self . shared_server_running . value ) def write_save_analog_img ( self , value ): self . _save_analog_img = value def read_save_analog_img ( self ): return self . _save_analog_img def write_save_threshold_img ( self , value ): self . _save_threshold_img = value def read_save_threshold_img ( self ): return self . _save_threshold_img def write_save_counting_img ( self , value ): self . _save_counting_img = value def read_save_counting_img ( self ): return self . _save_counting_img # when processing is ready -> self.push_change_event(self, \"analog_img\"/\"counting_img\"/\"threshold_img\") async def main ( self ): while True : frame_index , array = await self . get_msg_pair () print ( frame_index , array ) future = self . _process_pool . submit ( processing_func , frame_index , array , self . shared_memory_analog_img , self . _lock , ) future = asyncio . wrap_future ( future ) async def get_msg_pair ( self ): isJSON = True array = np . zeros ([ 400 , 400 ], dtype = np . uint16 ) msg1 = await self . _socket . recv () try : header = json . loads ( msg1 ) except : isJSON = False if isJSON : msg2 = await self . _socket . recv () array = np . frombuffer ( msg2 , dtype = np . uint16 ) . reshape (( 400 , 400 )) return header , array def _read_shared_array ( self , shared_memory , flip : bool ): array = np . ndarray (( 400 , 400 ), dtype = float , buffer = shared_memory . buf ) if flip : return np . flipud ( array ) else : return array @command def start_receiver ( self ): self . write_server_running ( True ) pass @command def stop_receiver ( self ): self . write_server_running ( False ) # self.save_files() @command def acquire_pedestals ( self ): pass def init_device ( self ): Device . init_device ( self ) self . get_device_properties ( self . get_device_class ()) # sync manager for synchronization between threads self . _manager = mp . Manager () # using simple mutex (lock) to synchronize self . _lock = self . _manager . Lock () # manager for allocation of shared memory between threads self . _shared_memory_manager = SharedMemoryManager () # starting the shared memory manager self . _shared_memory_manager . start () # default values of properties do not work without database though \u00af\\_(\u30c4)_/\u00af processing_cores_amount = 16 # self.PROCESSING_CORES zmq_ip = self . ZMQ_RX_IP zmq_port = self . ZMQ_RX_PORT # using shared threadsafe Value instance from multiprocessing self . shared_threshold = self . _manager . Value ( \"f\" , 0 ) self . shared_counting_threshold = self . _manager . Value ( \"f\" , 0 ) self . shared_server_running = self . _manager . Value ( \"b\" , 0 ) self . shared_processed_frames = self . _manager . Value ( \"I\" , 0 ) self . shared_amount_frames = self . _manager . Value ( \"I\" , 0 ) \"\"\" Here is a small explanation why the threshold is handled in other way as images buffers: Despite the fact there is a thread safe \"multiprocessing.Value\" class for scalars (see above), there is no class for 2D array. Yes, there are 1D arrays available (see \"multiprocessing.Array\"), but they need to be handled as python arrays and not as numpy arrays. Continuos rearrangement of them into numpy arrays and vise versa considered as bad. In python 3.8 shared memory feature was introduced which allows to work directly with memory and use a numpy array as proxy to it. Documentation: https://docs.python.org/3.8/library/multiprocessing.shared_memory.html A good example: https://luis-sena.medium.com/sharing-big-numpy-arrays-across-python-processes-abf0dc2a0ab2 tl;dr: we are able to share any numpy array between processes but in little other way \"\"\" # calculating how many bytes need to be allocated and shared for a 400x400 float numpy array img_bytes = np . zeros ([ 400 , 400 ], dtype = float ) . nbytes # allocating 4 arrays of this type self . shared_memory_pedestal = self . _shared_memory_manager . SharedMemory ( size = img_bytes ) self . shared_memory_analog_img = self . _shared_memory_manager . SharedMemory ( size = img_bytes ) self . shared_memory_threshold_img = self . _shared_memory_manager . SharedMemory ( size = img_bytes ) self . shared_memory_counting_img = self . _shared_memory_manager . SharedMemory ( size = img_bytes ) # creating thread pool executor to which the frame processing will be assigned self . _process_pool = ProcessPoolExecutor ( processing_cores_amount ) # creating and initialing socket to read from self . _init_zmq_socket ( zmq_ip , zmq_port ) loop = asyncio . get_event_loop () loop . create_task ( self . main ()) # initialization of tango events for pictures buffers self . set_change_event ( \"analog_img\" , True , False ) self . set_change_event ( \"threshold_img\" , True , False ) self . set_change_event ( \"counting_img\" , True , False ) # updating of tango events for pictures buffers def update_images_events ( self ): self . push_change_event ( \"analog_img\" ) self . push_change_event ( \"threshold_img\" ) self . push_change_event ( \"counting_img\" ) # save files on disk for pictures buffers def save_files ( self , path , filename , index ): \"\"\"Function for saving the buffered images in .tiff format. The files will have different postfixes depending on processing mode. Args: path (str): folder to save filename (str): name to save index (str): capture index \"\"\" savepath = os . path . join ( path , filename ) if self . read_save_analog_img (): im = Image . fromarray ( self . read_analog_img ()) im . save ( f \" { savepath } _ { index } _analog.tiff\" ) if self . read_save_threshold_img (): im = Image . fromarray ( self . read_threshold_img ()) im . save ( f \" { savepath } _ { index } _threshold_ { self . read_threshold () } .tiff\" ) if self . read_save_counting_img (): im = Image . fromarray ( self . read_analog_img ()) im . save ( f \" { savepath } _ { index } _counting_ { self . read_counting_threshold () } .tiff\" ) def _init_zmq_socket ( self , zmq_ip : str , zmq_port : str ): endpoint = f \"tcp:// { zmq_ip } : { zmq_port } \" self . _context = zmq . asyncio . Context () self . _socket = self . _context . socket ( zmq . SUB ) print ( f \"Connecting to: { endpoint } \" ) self . _socket . connect ( endpoint ) self . _socket . setsockopt ( zmq . SUBSCRIBE , b \"\" ) def delete_device ( self ): self . _process_pool . shutdown () self . _manager . shutdown () self . _shared_memory_manager . shutdown () save_files ( path , filename , index ) Function for saving the buffered images in .tiff format. The files will have different postfixes depending on processing mode. Parameters: Name Type Description Default path str folder to save required filename str name to save required index str capture index required Source code in pytango-moenchZmqServer\\MoenchZmqServer.py 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 def save_files ( self , path , filename , index ): \"\"\"Function for saving the buffered images in .tiff format. The files will have different postfixes depending on processing mode. Args: path (str): folder to save filename (str): name to save index (str): capture index \"\"\" savepath = os . path . join ( path , filename ) if self . read_save_analog_img (): im = Image . fromarray ( self . read_analog_img ()) im . save ( f \" { savepath } _ { index } _analog.tiff\" ) if self . read_save_threshold_img (): im = Image . fromarray ( self . read_threshold_img ()) im . save ( f \" { savepath } _ { index } _threshold_ { self . read_threshold () } .tiff\" ) if self . read_save_counting_img (): im = Image . fromarray ( self . read_analog_img ()) im . save ( f \" { savepath } _ { index } _counting_ { self . read_counting_threshold () } .tiff\" )","title":"Code reference"},{"location":"reference/#reference","text":"","title":"Reference"},{"location":"reference/#MoenchZmqServer.MoenchZmqServer","text":"Bases: Device Custom implementation of zmq processing server for X-ray detector M\u00d6NCH made in PSI which is integrated with a Tango device server. Source code in pytango-moenchZmqServer\\MoenchZmqServer.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 class MoenchZmqServer ( Device ): \"\"\"Custom implementation of zmq processing server for X-ray detector M\u00d6NCH made in PSI which is integrated with a Tango device server.\"\"\" _manager = None _context = None _socket = None _process_pool = None green_mode = GreenMode . Asyncio # probably should be rearranged in array, because there will pumped and unpumped images, for each type of processing # and further loaded with dynamic attributes shared_memory_pedestal = None shared_memory_analog_img = None shared_memory_threshold_img = None shared_memory_counting_img = None shared_threshold = None shared_counting_threshold = None shared_processed_frames = None shared_amount_frames = None shared_server_running = False _save_analog_img = True _save_threshold_img = True _save_counting_img = True ZMQ_RX_IP = device_property ( dtype = str , doc = \"port of the slsReceiver instance, must match the config\" , default_value = \"192.168.2.200\" , ) ZMQ_RX_PORT = device_property ( dtype = str , doc = \"ip of slsReceiver instance, must match the config\" , default_value = \"50003\" , ) PROCESSING_CORES = device_property ( dtype = int , doc = \"cores amount to process, up to 72 on MOENCH workstation\" , default_value = 20 , ) FLIP_IMAGE = device_property ( dtype = bool , doc = \"should the final image be flipped/inverted along y-axis\" , default_value = True , ) pedestal = attribute ( display_level = DispLevel . EXPERT , label = \"pedestal\" , dtype = float , dformat = AttrDataFormat . IMAGE , max_dim_x = 400 , max_dim_y = 400 , access = AttrWriteType . READ_WRITE , doc = \"pedestal (averaged dark images), i.e. offset which will be subtracted from each acquired picture\" , ) analog_img = attribute ( display_level = DispLevel . EXPERT , label = \"analog img\" , dtype = float , dformat = AttrDataFormat . IMAGE , max_dim_x = 400 , max_dim_y = 400 , access = AttrWriteType . READ , doc = \"sum of images processed with subtracted pedestals\" , ) threshold_img = attribute ( display_level = DispLevel . EXPERT , label = \"threshold img\" , dtype = float , dformat = AttrDataFormat . IMAGE , max_dim_x = 400 , max_dim_y = 400 , access = AttrWriteType . READ , doc = 'sum of \"analog images\" (with subtracted pedestal) processed with thresholding algorithm' , ) counting_img = attribute ( display_level = DispLevel . EXPERT , label = \"counting img\" , dtype = float , dformat = AttrDataFormat . IMAGE , max_dim_x = 400 , max_dim_y = 400 , access = AttrWriteType . READ , doc = 'sum of \"analog images\" (with subtracted pedestal) processed with counting algorithm' , ) threshold = attribute ( label = \"th\" , unit = \"ADU\" , dtype = float , access = AttrWriteType . READ_WRITE , hw_memorized = True , doc = \"cut-off value for thresholding\" , ) counting_threshold = attribute ( label = \"counting th\" , unit = \"ADU\" , dtype = float , access = AttrWriteType . READ_WRITE , hw_memorized = True , doc = \"cut-off value for counting\" , ) processed_frames = attribute ( label = \"proc frames\" , dtype = int , access = AttrWriteType . READ_WRITE , doc = \"amount of already processed frames\" , ) amount_frames = attribute ( label = \"amount frames\" , dtype = int , access = AttrWriteType . READ_WRITE , doc = \"expected frames to receive from detector\" , ) server_running = attribute ( display_level = DispLevel . EXPERT , label = \"is server running?\" , dtype = bool , access = AttrWriteType . READ_WRITE , doc = \"if true - server is running, otherwise - not\" , ) save_analog_img = attribute ( label = \"save analog\" , dtype = bool , access = AttrWriteType . READ_WRITE , memorized = True , hw_memorized = True , doc = \"save analog .tiff file after acquisition\" , ) save_threshold_img = attribute ( label = \"save threshold\" , dtype = bool , access = AttrWriteType . READ_WRITE , memorized = True , hw_memorized = True , doc = \"save threshold .tiff file after acquisition\" , ) save_counting_img = attribute ( label = \"save counting\" , dtype = bool , access = AttrWriteType . READ_WRITE , memorized = True , hw_memorized = True , doc = \"save counting .tiff file after acquisition\" , ) def write_pedestal ( self , value ): self . shared_pedestal . value = value def read_pedestal ( self ): return self . _read_shared_array ( shared_memory = self . shared_memory_pedestal , flip = self . FLIP_IMAGE ) def write_analog_img ( self , value ): self . shared_analog_img . value = value def read_analog_img ( self ): return self . _read_shared_array ( shared_memory = self . shared_memory_analog_img , flip = self . FLIP_IMAGE ) def write_threshold_img ( self , value ): self . shared_threshold_img . value = value def read_threshold_img ( self ): return self . _read_shared_array ( shared_memory = self . shared_memory_threshold_img , flip = self . FLIP_IMAGE ) def write_counting_img ( self , value ): self . shared_counting_img . value = value def read_counting_img ( self ): return self . _read_shared_array ( shared_memory = self . shared_memory_counting_img , flip = self . FLIP_IMAGE ) def write_threshold ( self , value ): self . shared_threshold . value = value def read_threshold ( self ): return self . shared_threshold . value def write_counting_threshold ( self , value ): self . shared_counting_threshold . value = value def read_counting_threshold ( self ): return self . shared_counting_threshold . value def write_processed_frames ( self , value ): self . shared_processed_frames . value = value def read_processed_frames ( self ): return self . shared_processed_frames . value def write_amount_frames ( self , value ): self . shared_amount_frames . value = value def read_amount_frames ( self ): return self . shared_amount_frames . value def write_server_running ( self , value ): self . shared_server_running . value = int ( value ) def read_server_running ( self ): return bool ( self . shared_server_running . value ) def write_save_analog_img ( self , value ): self . _save_analog_img = value def read_save_analog_img ( self ): return self . _save_analog_img def write_save_threshold_img ( self , value ): self . _save_threshold_img = value def read_save_threshold_img ( self ): return self . _save_threshold_img def write_save_counting_img ( self , value ): self . _save_counting_img = value def read_save_counting_img ( self ): return self . _save_counting_img # when processing is ready -> self.push_change_event(self, \"analog_img\"/\"counting_img\"/\"threshold_img\") async def main ( self ): while True : frame_index , array = await self . get_msg_pair () print ( frame_index , array ) future = self . _process_pool . submit ( processing_func , frame_index , array , self . shared_memory_analog_img , self . _lock , ) future = asyncio . wrap_future ( future ) async def get_msg_pair ( self ): isJSON = True array = np . zeros ([ 400 , 400 ], dtype = np . uint16 ) msg1 = await self . _socket . recv () try : header = json . loads ( msg1 ) except : isJSON = False if isJSON : msg2 = await self . _socket . recv () array = np . frombuffer ( msg2 , dtype = np . uint16 ) . reshape (( 400 , 400 )) return header , array def _read_shared_array ( self , shared_memory , flip : bool ): array = np . ndarray (( 400 , 400 ), dtype = float , buffer = shared_memory . buf ) if flip : return np . flipud ( array ) else : return array @command def start_receiver ( self ): self . write_server_running ( True ) pass @command def stop_receiver ( self ): self . write_server_running ( False ) # self.save_files() @command def acquire_pedestals ( self ): pass def init_device ( self ): Device . init_device ( self ) self . get_device_properties ( self . get_device_class ()) # sync manager for synchronization between threads self . _manager = mp . Manager () # using simple mutex (lock) to synchronize self . _lock = self . _manager . Lock () # manager for allocation of shared memory between threads self . _shared_memory_manager = SharedMemoryManager () # starting the shared memory manager self . _shared_memory_manager . start () # default values of properties do not work without database though \u00af\\_(\u30c4)_/\u00af processing_cores_amount = 16 # self.PROCESSING_CORES zmq_ip = self . ZMQ_RX_IP zmq_port = self . ZMQ_RX_PORT # using shared threadsafe Value instance from multiprocessing self . shared_threshold = self . _manager . Value ( \"f\" , 0 ) self . shared_counting_threshold = self . _manager . Value ( \"f\" , 0 ) self . shared_server_running = self . _manager . Value ( \"b\" , 0 ) self . shared_processed_frames = self . _manager . Value ( \"I\" , 0 ) self . shared_amount_frames = self . _manager . Value ( \"I\" , 0 ) \"\"\" Here is a small explanation why the threshold is handled in other way as images buffers: Despite the fact there is a thread safe \"multiprocessing.Value\" class for scalars (see above), there is no class for 2D array. Yes, there are 1D arrays available (see \"multiprocessing.Array\"), but they need to be handled as python arrays and not as numpy arrays. Continuos rearrangement of them into numpy arrays and vise versa considered as bad. In python 3.8 shared memory feature was introduced which allows to work directly with memory and use a numpy array as proxy to it. Documentation: https://docs.python.org/3.8/library/multiprocessing.shared_memory.html A good example: https://luis-sena.medium.com/sharing-big-numpy-arrays-across-python-processes-abf0dc2a0ab2 tl;dr: we are able to share any numpy array between processes but in little other way \"\"\" # calculating how many bytes need to be allocated and shared for a 400x400 float numpy array img_bytes = np . zeros ([ 400 , 400 ], dtype = float ) . nbytes # allocating 4 arrays of this type self . shared_memory_pedestal = self . _shared_memory_manager . SharedMemory ( size = img_bytes ) self . shared_memory_analog_img = self . _shared_memory_manager . SharedMemory ( size = img_bytes ) self . shared_memory_threshold_img = self . _shared_memory_manager . SharedMemory ( size = img_bytes ) self . shared_memory_counting_img = self . _shared_memory_manager . SharedMemory ( size = img_bytes ) # creating thread pool executor to which the frame processing will be assigned self . _process_pool = ProcessPoolExecutor ( processing_cores_amount ) # creating and initialing socket to read from self . _init_zmq_socket ( zmq_ip , zmq_port ) loop = asyncio . get_event_loop () loop . create_task ( self . main ()) # initialization of tango events for pictures buffers self . set_change_event ( \"analog_img\" , True , False ) self . set_change_event ( \"threshold_img\" , True , False ) self . set_change_event ( \"counting_img\" , True , False ) # updating of tango events for pictures buffers def update_images_events ( self ): self . push_change_event ( \"analog_img\" ) self . push_change_event ( \"threshold_img\" ) self . push_change_event ( \"counting_img\" ) # save files on disk for pictures buffers def save_files ( self , path , filename , index ): \"\"\"Function for saving the buffered images in .tiff format. The files will have different postfixes depending on processing mode. Args: path (str): folder to save filename (str): name to save index (str): capture index \"\"\" savepath = os . path . join ( path , filename ) if self . read_save_analog_img (): im = Image . fromarray ( self . read_analog_img ()) im . save ( f \" { savepath } _ { index } _analog.tiff\" ) if self . read_save_threshold_img (): im = Image . fromarray ( self . read_threshold_img ()) im . save ( f \" { savepath } _ { index } _threshold_ { self . read_threshold () } .tiff\" ) if self . read_save_counting_img (): im = Image . fromarray ( self . read_analog_img ()) im . save ( f \" { savepath } _ { index } _counting_ { self . read_counting_threshold () } .tiff\" ) def _init_zmq_socket ( self , zmq_ip : str , zmq_port : str ): endpoint = f \"tcp:// { zmq_ip } : { zmq_port } \" self . _context = zmq . asyncio . Context () self . _socket = self . _context . socket ( zmq . SUB ) print ( f \"Connecting to: { endpoint } \" ) self . _socket . connect ( endpoint ) self . _socket . setsockopt ( zmq . SUBSCRIBE , b \"\" ) def delete_device ( self ): self . _process_pool . shutdown () self . _manager . shutdown () self . _shared_memory_manager . shutdown ()","title":"MoenchZmqServer"},{"location":"reference/#MoenchZmqServer.MoenchZmqServer.save_files","text":"Function for saving the buffered images in .tiff format. The files will have different postfixes depending on processing mode. Parameters: Name Type Description Default path str folder to save required filename str name to save required index str capture index required Source code in pytango-moenchZmqServer\\MoenchZmqServer.py 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 def save_files ( self , path , filename , index ): \"\"\"Function for saving the buffered images in .tiff format. The files will have different postfixes depending on processing mode. Args: path (str): folder to save filename (str): name to save index (str): capture index \"\"\" savepath = os . path . join ( path , filename ) if self . read_save_analog_img (): im = Image . fromarray ( self . read_analog_img ()) im . save ( f \" { savepath } _ { index } _analog.tiff\" ) if self . read_save_threshold_img (): im = Image . fromarray ( self . read_threshold_img ()) im . save ( f \" { savepath } _ { index } _threshold_ { self . read_threshold () } .tiff\" ) if self . read_save_counting_img (): im = Image . fromarray ( self . read_analog_img ()) im . save ( f \" { savepath } _ { index } _counting_ { self . read_counting_threshold () } .tiff\" )","title":"save_files()"}]}